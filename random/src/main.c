#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/time.h>

#include "random.h"
#include "utils.h"
#include "consts.h"
#include "codegen.h"


void verify_consts();

int main( int argc, const char* argv[] )
{

	verify_consts();

	int pid;
	int *child_pids = (int*) malloc(sizeof(int)*MAX_THREADS);

	unsigned int nThread;

	for (nThread = MAX_THREADS; nThread > 0; nThread--) {
		if ((pid = fork()) == 0)
			break;

		child_pids[nThread-1] = pid;
	}

	/*printf("Hello, I'm thread %i and my pid is %i and my childs are %i, %i, %i, ... !\n", nThread, pid, child_pids[0], child_pids[1], child_pids[2]);*/

	/*-- CHILDS --*/
	if(nThread != 0) {
		rand_init();

		char *programmName = (char*) calloc(100, sizeof(char));
		char *programmPath = (char*) calloc(100, sizeof(char));
		char *errorLine = (char*) calloc(100, sizeof(char));
		unsigned int nProgramm = (nThread-1)*PROGRAMM_PER_THREAD;

		while((nProgramm++) < nThread*PROGRAMM_PER_THREAD) {

			char *programm = newProgramm();

			sprintf(programmName, "test_%u.deca", nProgramm);
			sprintf(programmPath, "deca/%s", programmName);

			FILE *file = fopen(programmPath, "w");
			if (file == NULL) {
				printf("\nImpossible de crÃ©er le fichier %s !", programmPath);
				return EXIT_FAILURE;
			}

			fprintf(file, "//Autogenerated programm %u\n", nProgramm);
			fprintf(file, "//Generated by thread %i\n%s", nThread, programm);

			fclose(file);

			free(programm);
		}

		free(programmName);
		free(programmPath);
		free(errorLine);
	} 

	/*-- MAIN --*/
	else { 
		printf("Launched %i threads, generating %i files each !\n", MAX_THREADS, PROGRAMM_PER_THREAD);

		/*struct timeval *tv = (struct timeval *) malloc(sizeof(struct timeval));*/
		struct timeval tv1, tv2;

		gettimeofday(&tv1, NULL);

		int status;
		wait(&status);

		gettimeofday(&tv2, NULL);

		unsigned long int t1 = 1000*tv1.tv_sec + tv1.tv_usec/1000;
		unsigned long int t2 = 1000*tv2.tv_sec + tv2.tv_usec/1000;
		unsigned long int dt = t2 - t1;

		printf("Done in %lu ms !\n", dt);

		printf("Compiling in parallel ...\n");

		gettimeofday(&tv1, NULL);

		printf("decac -P -n deca/*.deca\n");
		system("decac -P deca/*.deca > /dev/null");

		gettimeofday(&tv2, NULL);

		t1 = 1000*tv1.tv_sec + tv1.tv_usec/1000;
		t2 = 1000*tv2.tv_sec + tv2.tv_usec/1000;
		dt = t2 - t1;

		printf("\nDone in %lu ms !\n", dt);

		printf("Looking for *.ass !\n");

		DIR *dir;
		struct dirent *ent;
		unsigned int counter = 0;
		char filename[256];
		char dst[256];

		if (chdir("deca")) {
			printf("\nImpossible d'ouvrir le dossier deca !");
		}

		dir = opendir(".");

		if (dir == NULL) {
			printf("\nImpossible d'ouvrir le dossier deca !\n");
			return EXIT_FAILURE;
		}
	
		/*On cherche les *.ass*/
		while((ent = readdir(dir)) != NULL) {
			if(ent->d_type == DT_REG && (strstr(ent->d_name, ".ass") != NULL)) {
				printf("Found %s !\n", ent->d_name);
				strncpy(filename, ent->d_name, strlen(ent->d_name) - 4);
				filename[strlen(ent->d_name) - 4] = '\0';
				strcat(filename, ".deca");
				sprintf(dst, "../valid/%s", filename);
				if (cp(dst,filename) != 0)
					printf("ERROR during copy from %s to %s!\n", filename, dst);

				counter++;
			}
		}
		
		printf("Found %i successfully compiled files !\n", counter);
		printf("Deleting all sources files ...\n");

		rewinddir(dir);
		
		/*On supprime tout*/
		while((ent = readdir(dir)) != NULL) {
			if(ent->d_type == DT_REG) {
				remove(ent->d_name);
			}
		}
		
		printf("Done.\n");

		closedir(dir);


	}

	free(child_pids);
	return EXIT_SUCCESS;
}

